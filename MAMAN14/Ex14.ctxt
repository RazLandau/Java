#BlueJ class context
comment0.params=mat
comment0.target=int\ isSink(int[][])
comment0.text=\r\n\ This\ method\ recieves\ a\ Matrix\ filled\ with\ 0\ and\ 1,\ and\ checks\ if\ there\ is\ a\ "sink"\ in\ that\ Matrix.\r\n\ A\ "sink"\ is\ when\ an\ entire\ row\ is\ filled\ with\ 0\ and\ the\ same\ entire\ column\ is\ filled\ with\ 1\ (except\ for\ the\ intersect\ sqaure,\ which\ is\ the\ "sink").\r\n\ This\ method\ returns\ the\ sink\ in\ the\ given\ Matrix,\ and\ -1\ if\ there\ isn't\ a\ sink\ in\ the\ Matrix.\r\n\ This\ methods\ uses\ 2\ private\ methods.\r\n\ The\ complexity\ of\ this\ method\ is\ O(n).\r\n\ The\ memory\ complexity\ of\ this\ method\ is\ O(1),\ since\ none\ of\ the\ memory\ we\ use\ is\ relative\ to\ n.\r\n\ @param\ mat\ The\ given\ Matrix\r\n\ @return\ The\ sink\ (returns\ -1\ if\ there\ isn't\ a\ sink)\r\n
comment1.params=mat
comment1.target=int\ escapeMatrix(int[][])
comment1.text=\r\n\ This\ method\ "escapes"\ the\ array\ "diagnoly"\ like\ right-downard\ steps,\ in\ the\ following\ way\:\r\n\ \ \ \ \ \ \ starts\ with\ the\ upper\ leftmost\ corner,\ then\ if\ index\ is\ 0-\ moves\ 1\ column\ right;\ and\ if\ it's\ 1-\ moves\ 1\ row\ down,\ until\ it\ reaches\ the\ length\ of\ the\ Matrix.\r\n\ The\ logic\ is\ that\ if\ the\ index\ square\ is\ 0-\ The\ whole\ column\ is\ dismissed,\ and\ if\ it's\ 1-\ The\ whole\ row\ is\ dismissed,\ according\ to\ the\ defiinition\ of\ "sink".\r\n\ The\ runtime\ complexity\ of\ this\ method\ is\ O(n)\ (Worst\ case\ \=\ O(2n))\r\n\ The\ memory\ complexity\ of\ this\ method\ is\ O(1),\ since\ none\ of\ the\ memory\ we\ use\ is\ relative\ to\ n.\r\n\ @param\ mat\ The\ given\ Matrix\r\n\ @return\ The\ row\ we\ exited\ from\ (-1\ if\ we\ exited\ the\ Matrix\ from\ the\ bottom)\r\n
comment2.params=mat\ potentialSink
comment2.target=int\ checkPotentialSink(int[][],\ int)
comment2.text=\r\n\ This\ method\ completes\ method\ escapeMatrix\ and\ checks\ if\ potential\ sink\ is\ indeed\ a\ valid\ sink\ by\ checking\ the\ sum\ of\ its\ row\ and\ column.\r\n\ The\ runtime\ complexity\ of\ this\ method\ is\ O(n),\ since\ we\ use\ a\ loop\ to\ sum\ up\ 1\ column\ and\ 1\ row\ (2n).\r\n\ The\ memory\ complexity\ of\ this\ method\ is\ O(1),\ since\ none\ of\ the\ memory\ we\ use\ is\ relative\ to\ n.\r\n\ @param\ mat\ The\ given\ Matrix\r\n\ @param\ potentialSink\ the\ potentialSink\r\n\ @return\ confirmed\ sink\ (-1\ if\ potential\ sink\ is\ NOT\ valid)\r\n
comment3.params=mat\ x
comment3.target=boolean\ find(int[][],\ int)
comment3.text=\r\n\ This\ method\ recieves\ a\ sqaured\ Matrix\ the\ size\ of\ 2^k\ for\ a\ neutral\ k,\ filled\ with\ numbers,\ ordered\ by\ size\ recursivly\ clock-wise,\ and\ checks\ if\ given\r\n\ \ \ \ \ \ \ number\ is\ in\ that\ Matrix.\r\n\ This\ method\ uses\ Binary\ Search\ to\ find\ the\ number\ in\ the\ ordered\ array,\ there\ for\ its\ complexity\ is\ O(longn).\r\n\ The\ memory\ complexity\ of\ this\ method\ is\ O(1),\ since\ none\ of\ the\ memory\ we\ use\ is\ relative\ to\ n.\r\n\ @param\ mat\ The\ given\ Matrix\r\n\ @param\ x\ The\ searched\ number\r\n\ @return\ True\ if\ number\ is\ in\ the\ Matrix,\ false\ if\ not\r\n
comment4.params=mat\ row\ col
comment4.target=int\ stain(char[][],\ int,\ int)
comment4.text=\r\n\ This\ method\ recieves\ a\ Matrix\ filled\ with\ x's\ and\ blanks,\ and\ returns\ the\ stain\ size\ of\ given\ specific\ square\ in\ that\ Matrix.\r\n\ A\ stain\ is\ a\ group\ of\ adjacent\ x\ sqaures\ (diagnoals\ count)\ of\ given\ coordinate.\r\n\ @param\ mat\ The\ given\ Matrix\r\n\ @param\ row\ The\ y\ coordinate\ of\ given\ point\ (starts\ with\ 0)\r\n\ @param\ col\ The\ x\ coordinate\ of\ given\ point\ (starts\ with\ 0)\r\n\ @return\ The\ stain\ size\r\n
comment5.params=arr\ num
comment5.target=boolean\ isFillBag(int[],\ int)
comment5.text=\r\n\ This\ method\ recieves\ an\ array\ of\ numbers\ and\ a\ single\ number,\ and\ checks\ if\ any\ combination\ of\ the\ numbers\r\n\ \ \ \ \ in\ the\ array\ can\ add\ up\ to\ the\ given\ number.\ \r\n\ If\ there\ is\ such\ combination-\ Prints\ the\ numbers\ in\ the\ array\ that\ were\ used.\r\n\ This\ method\ uses\ an\ overloading\ private\ method.\r\n\ @param\ arr\ Given\ array\r\n\ @param\ num\ The\ given\ inspired\ sum\r\n\ @return\ True\ if\ sucessful,\ false\ if\ not\r\n
comment6.params=values\ i\ amount
comment6.target=boolean\ isFillBag(int[],\ int,\ int)
comment6.text=\r\n\ This\ method\ uses\ recursivity\ and\ backtracking\ by\ always\ checking\ 2\ situations\:\ \r\n\ \ \ \ \ \ \ "Taking"\ the\ index\ number\ (and\ substracting\ it\ from\ the\ inspired\ sum),\ or\ NOT\ taking\ it;\r\n\ \ \ \ \ \ \ then\ uses\ a\ recursive\ call\ on\ the\ array\ without\ that\ number.\r\n\ \ \ \ \ \ \ Finally,\ prints\ the\ numbers\ that\ were\ used.\r\n\ @param\ values\ The\ given\ array\r\n\ @param\ i\ The\ index\r\n\ @param\ amount\ The\ given\ number\ (inspired\ sum)\r\n\ @return\ True\ if\ sucessful,\ false\ if\ not\r\n
numComments=7
